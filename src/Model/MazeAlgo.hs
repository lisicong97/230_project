-- TODO: automatically generate a maze, see brick lib: Maze, below is simple backtracking algo,
-- still need cooperation with our code, no time to finish.
-- import Data.Array.ST
-- import Data.STRef
-- import Data.Word
-- import System.Random
-- import Control.Monad ( forM_, when )
-- import Control.Monad.ST
-- module Maze.Core
--   ( -- * Coordinates, directions, and walls
--     Coord
--   , coordRow
--   , coordCol
--   , Wall
--   , wallNeighbors
--   , wallDirection
--   , Direction(..)
--     -- * Mutable maze
--   , STMaze
--   , newSTMaze
--   , stMazeBounds
--   , stMazeInnerWalls
--   , stMazeNeighborCoords
--   , stMazeOpenCoordDir
--   , stMazeOpenWall
--     -- * Immutable maze
--   , IMaze
--   , freezeSTMaze
--   , iMazeBounds
--   , iMazeMove
--   , iMazeCoords
--   ) where
-- -- create maze using recursive backtracking algorithm
-- createMaze :: RandomGen g => g -> Word32 -> Word32 -> (IMaze, g)
-- createMaze g rows cols = runST $ do
--   gRef         <- newSTRef g
--   maze         <- newSTMaze rows cols
--   mazeBounds   <- stMazeBounds maze
--   cellsVisited <- newArray mazeBounds False
--   let (coord:_) = range mazeBounds
--   createMaze' gRef maze coord cellsVisited
--   imaze        <- freezeSTMaze maze
--   g'           <- readSTRef gRef
--   return (imaze, g')
--   where createMaze' :: RandomGen g
--                                => STRef s g
--                                -> STMaze s
--                                -> Coord
--                                -- ^ Position we are currently at in the maze.
--                                -> STArray s Coord Bool
--                                -- ^ Table telling us whether we have visited
--                                -- each coordinate yet.
--                                -> ST s ()
--         createMaze' gRef maze pos cellsVisited = do
--           -- Mark this coordinate as visited.
--           writeArray cellsVisited pos True
--           -- Get the neighbors of this cell.
--           neighbors <- stMazeNeighborCoords maze pos
--           -- Shuffle the list of neighbors, writing back the new random
--           -- generator when we're done.
--           g <- readSTRef gRef
--           let (neighbors', g') = shuffle neighbors g
--           writeSTRef gRef g'
--           -- For each neighbor, if it has not been visited already, visit it by removing
--           -- the wall between the current cell and the neighbor, and be recursively
--           -- calling @createMaze'@ on the neighbor.
--           forM_ neighbors' $ \(dir, nPos) -> do
--             visited <- readArray cellsVisited nPos
--             when (not visited) $ do
--               stMazeOpenCoordDir maze pos dir
--               createMaze' gRef maze nPos cellsVisited